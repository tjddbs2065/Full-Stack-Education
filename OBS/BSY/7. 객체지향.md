
##### 소프트웨어 개발 방법론
1. 구조적 방법론: input → process → output
	- ==기능(process)을 중심==으로 개발하는 과정
2. 정보공학 방법론: 
	- ==값(Data)를 중심==으로 개발하는 과정
	- 데이터를 보관하고 오래 유지하는 것이 중요(데이터의 중복 제거가 핵심)
	- 분산화: 다양한 네트워크 프로토콜을 사용
3. 객체지향 방법론
	- ==기능과 값을 하나의 단위로 묶은 것을 중심==으로 개발하는 과정
	- http 하나의 프로토콜을 사용(web 2.0 = 비동기 서비스 제공 시작)
	
	＊ 동기: 데이터의 변경이 필요할 때 사용
	＊ 비동기: 데이터의 변경이 필요없을 때(단순 조회)가 필요할 때

##### ○ 객체(Object)의 구성요소
- Data: 값(Member Data)
- Operation: 기능(Member Operation / Method, Constructor)
##### ○ 객체(Object)의 특징
- Object
	- 프로그램의 대상
	- ==Data와 Operation==으로 구분된다.
- Class
	- 객체를 구체화 한 틀
- Abstraction(추상화)
	- 객체를 ==분석, 설계==하는 일련의 과정

##### ○ 객체지향 특성
- Abstraction: 추상화(분석/설계)
- Encapsulation: 캡슐화(내부 데이터 보호)
	- ex) api 문서의 경우 공개하지 않는 속성이 있을 때 굳이  문서에 표시하지는 않기에 getter나 setter 메서드로 이를 확인할 수 있다.
- Inheritance: 상속(재사용)
- Polymorphism: 다형성(다양한 구현부 = 재정의)
- Interface: 선언부(input과 output의 정보를 가진다.)
- Implementation: 메서드의 구현부
- Instantiation: 객체화(new -> heap => 생성패턴)
- Overriding:
- Overloading:

##### ○ 코드에서 중요한 것
-  문법
-  가독성 = 의미 전달
※ '문법'에서는 ==타입만== 고려하고 '객체'에서는 ==의미 전달(이름-식별자)==까지 고려해야 한다.
	→ 객체 지향 언어에서는 의미 전달이 매우 중요하다.


##### ○ 객체는 스택에 쌓이지 않고 힙에 생성하여 스택에 메모리가 계속해서 쌓이는 것을 방지한다.


Data: 값 => Value Object: VO 패턴
Class = 사용자 정의 타입

##### VO(Value Object)
- 입력값을 묶겠다(=데이터 구조체) : 데이터 관점에서 분석
##### DTO(Data Transfer Object)
- 출력값을 고정하겠다(=입력값의 타입이나 종류와는 무관하다 = 오버로딩)

##### `StudentVo s1 = new StrudentVo();`
 -> StudentVo 클래스의 멤버의 개수를 기반으로 메모리 할당을 한다.
 -> StudentVo() : 생성자

##### Access Modifier(접근 지정자)
 - public
 - protected
 - default: 같은 패키지에서는 public, 다른 패키지에서는 private으로 인식한다.
 - private:
-> 별도로 지정하지 않으면 default가 기본 값이다.

##### Data는 private을 기본으로 가지는 것으로 권장한다.
 -> data를 저장할 때 검증된 값 만을 저장을 해야 한다. 
 => 값을 관리하는 기능을 재사용이 가능하게 만들게 된다. 
 -> getXXX(), setXXX() : getter and setter

- 메모리 할당과 동시에 초기화 생성자
- 생성자를 정의하지 않으면 VM이 매개인자가 없는 생성자를 기본으로 생성한다.
- setXXX, getXXX 일반적으로 public 권장

- class의 멤버 데이터 - 일반적으로 data는 private을 권장한다.(public final static int MAX_VALUE= 100)

##### 클래스 다이어그램
- +: public
- -: private


Operation 
 - 생성자(Constructor)
 - 메서드(Method)

이름과 타입에 따라 구현한다 = class diagram 을 참고하여 구현한다.












