요구 사항을 통해 업무 분석을 할 때 완벽하게 설계할 수 없다.

상속 = 필수 관계(is - a)
포함/집합 = has - a

uml 해석
- 실선: 데이터 중심
- 점선: 기능 중심

- has a 관계


코드 지적
- 설계도의 네이밍 규칙은 그대로 사용한다
- 패키지의 네이밍은 소문자 작성하고 도메인의 형태로 3가지 부분을 가진다.
- 부모 클래스에 abstract를 붙였다는 것은 해당 부모 클래스의 객체를 생성하고 싶지 않다는 것
- 값을 넣을 때 boolean으로 추가가 성공했는 지 확인하거나, 넣고 출력을 반복해서 실제로 들어갔는 지 확인한다.


반환값이 void인 메서드는 내부에서 오류 발생 시 예외로 처리
테스트 경계가 명확하지 않은 것은 Junit Test

요구사항이 없으면 다양하게 해석할 수 있을 때 코드의 유연성이 있다고 한다
- 상속 = 1 : 1 관계 필수(메모리에 동시에 올라감)
- 관계수정 (=코드변경) 시 유연성이 하락 = 유지보수성 하락
※ 내가 당연한게 다른 사람한테도 당연한 것은 아니다. = 요구사항이 모호하면 내가 맘대로 정하지 말고 여러 경우를 포함하도록 한다.

상속이 아니라 매개 인자로 객체를 넘겨 관리하게 되면 코드의 유연성이 증가한다. 이를 합성이라고 한다.
- 상속의 경우 부모의 클래스 정보가 바뀌면 그 자식의 코드도 수정이 되어야 한다.
- 하지만 합성의 경우 매개인자로 넘겨받은 객체의 경우 코드 결합도가 낮기에 수정을 하지 않아도 된다.



##### 예외처리(Exception)
자바에서 메서드가 호출되면 그 메서드 내부의 메서드가 연달아서 호출된다. 
그 메서드 중 오류가 발생했을 때 return을 호출하면 해당 메서드가 종료한다.
하지만 해당 메서드만 종료되면 프로그램은 오류가 발생한 채로 방치되어 더욱 치명적일 수 있다.
때문에 해당 메서드 뿐만 아니라 최초 실행된 메서드나 원하는 곳까지 종료되어 최종적으로는 프로그램이 안정적으로 돌아가거나 종료되게 해야 한다.

이때 자바에서는 **==throw**==를 사용하여 종료 신호를 상위 메서드로 계속해서 보낼 수 있다. 
하지만 이 종료 신호는 중간에 잡아주지 않으면 최종적으로는 VM까지 신호가 전달되어 프로그램이 ==비정상 종료==가 되어버린다. 
이때 **==try/catch**==를 사용하여 안정적으로 throw 신호를 제어하고 에러가 어디서 발생했는지 알 수 있어야 한다. 이를 **==예외처리**==라고 한다.

Exception : 프로그램이 처리할 수 있는 ==예외 사항==(=소프트웨어 적인 요소로 인해 발생)
Error : 프로그램이 처리할 수 없는 **==심각한 오류**==(=개발자나 SW와 직접적인 연관이 없는 요소로 인해 발생)
- getMessage(): 에러 메시지를 출력한다.
- printStackTrace(): 예외가 발생하게 된 위치를 확인할 수 있도록 스택 구조를 출력해준다.

- 미리 구현된 Exception에 원하는 예외처리 클래스가 없을 경우에는 원하는 예외 처리를 상속받아 구현을 하면 된다. 단, 이름은 Exception을 꼭 붙여야 한다.

 - Exception 중 RuntimeException이 예외 중에서도 덜 위험한 예외
 - 그 외에는 발생할 확률이 높다. => 컴파일 체크


초창기 Java는 checkedException이 많았다. 당시 Java는 VM 바로 위에서 실행되었기에 초보자들이 실수하는 것을 막기 위해서이다.
웹서버가 발전하면서 Server나 Framework가 VM 위에서 동작하고 개발자의 코드는 그 위에서 동작하기에, 서버나 프레임워크에서 막아버리면 VM까지 그 예외가 전달되지 않는다. 때문에 RuntimeException은 서버에서 동작하는 것을 선호하고 CheckedException은 VM에서 동작하는 것을 선호한다.









