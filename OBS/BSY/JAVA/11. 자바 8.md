##### 요구사항과 설계
- 업무 분석을 통해 완벽한 설계는 불가능 → 요구사항은 항상 모호성이 존재.
- 요구사항이 불명확하면
	- 내가 당연한 것이 다른 사람에게는 당연하지 않을 수 있음
	- 임의로 단정하지 말고 여러 경우를 고려해 코드의 유연성을 확보해야 함
- 코드 유연성 = 다양한 해석과 변경을 수용할 수 있는 구조
	- 상속만 쓰면 유연성이 떨어짐
	- 합성(Composition)을 활용하면 코드 결합도가 낮아져 유지보수성이 올라감

##### 상속 vs 포함/집합
- 상속
	- 1:1 필수 관계, 메모리에 동시에 올라감
	- 부모 정보 변경 시 → 자식 코드까지 수정 필요 → 유지보수성 하락
	- 강한 연관관계 형성
- 포함/집합
	- 객체를 매개변수로 받아 관리
	- 코드 결합도가 낮아 수정 시 영향이 적음 → 유지보수성 향상
	- "상속보다는 합성을 선호하라"

##### UML 해석
- 실선: 데이터 중심 관계(상속, 포함 등)
- 점선: 기능 중심 관계(인터페이스 구현 등)
- `is-a`: 상속 관계
- `has-a`: 포함/집합 관계

##### 코드 설계 규칙
- 네이밍: 설계도(클래스 다이어그램)의 이름 규칙을 그대로 사용
- 패키지 이름: 소문자로 작성, 도메인 기반 3단 구조 권장
	- ex) `com.company.project`
- abstract 부모 클래스: 객체 생성을 막고, 자식이 구현하도록 의도
- 데이터 삽입 시 확인
	- `boolean` 반환으로 성공 여부 확인
	- 출력 반복으로 실제 삽입 확인

##### 메서드 반환값과 테스트
- `void` 반환 메서드 → 내부 오류 발생 시 반드시 예외 처리(throw)
- 테스트 경계가 모호하면 JUnit Test로 단위 테스트 필요

##### 예외 처리(Exception Handling)
- 기본원리
	- 메서드 실행 중 오류 발생 → `return`만 사용 시 해당 메서드만 종료됨 → 위험.
	- 자바에서는 `throw`를 사용 → 오류 신호를 상위 호출 메서드까지 전달
	- 만약 중간에 잡아주지 않으면 JVM까지 전달 → 비정상 종료
	- 따라서 `try/catch`로 오류를 제어해 프로그램이 안정적으로 종료되도록 함
- Exception vs Error
	- Exception(예외)
		- 프로그램이 처리할 수 있는 문제(소프트웨어적)
		- ex) 파일 없음, 잘못된 입력 등
	- Error(오류)
		- `getMessage()`: 에러 메시지 확인
		- `printStackTrace()`: 발생 위치를 스택 구조로 출력
- 사용자 정의 예외
	- 자바에 없는 예외 상황이 필요할 경우 → `Exception` 상속받아 정의
	- 클래스 이름 끝에는 반드시 `Exception` 붙이는 것이 규칙
- Checked vs Unchecked 예외
	- Checked Exception
		- 컴파일 시점에 반드시 처리 강제(`IOException`,`SQLException` 등)
		- 초기 자바(JVM 위에서 직접 동작할 때)는 Checked Exception이 많았음
	- Unchecked Exception(=RuntimeException 계열)
		- 상대적으로 위험도가 낮음, 컴파일러가 강제하지 않음(`NullPointerException`, `IllegalArgumentException` 등)
		- 웹 서버/프레임워크 발전 → 예외가 VM까지 전달되지 않음 → RuntimeException 선호
- 핵심 개념
	- `throw`: 예외 발생 신호를 상위 호출 메서드로 전달
	- `throws`: 메서드 선언부에 작성 → 이 메서드가 예외를 발생시킬 수 있음을 알림
- 예외 종류
	- Unchecked Exception
		- 실행 중에 발생
		- 컴파일러가 강제하지 않음
		- 주로 프로그래밍 오류
		- 개발자에게 선택권을 부여
	- Checked Exception
		- 컴파일 단계에서 반드시 처리 필요
		- `try/catch` 또는 `throws` 필수
		- 외부 요인(I/O, 네트워크, DB 등)에 의해 발생
- 예외 처리 방법
	- 예외를 어디서 제어할지 모르면 `main()`에서 try/catch
	- 원하는 예외 클래스가 없으면 → `Exception` 상속받아 사용자 정의 예외 클래스
	- 여러 예외를 `throws` 해야 할 때 → 테스트 코드에서는 단순히 `throws Exception`으로 한꺼번에 처리 가능
	- catch 블록 주의
		- `catch(Exception e)`는 모든 예외를 잡을 수 있음.
		- 하지만 특정 예외를 구분하지 못해, 세부적인 처리가 필요할 경우 예외별로 분리해야 함

##### Collection API
- 기본 구조
	- Collection: 최상위 인터페이스
		- `List`, `Set` 인터페이스가 이를 상속
	- List: 순서 보장,  중복 허용(`ArrayList`,`LinkedList`)
	- Set: 순서 없음, 중복 불가(`HashSet`, `TreeSet`)
- 구현 계층
	- `Collection`(최상위 인터페이스)
		- `List`, `Set` 인터페이스
		- `AbstractList`, `AbstractSet` (중간 추상 클래스, 공통 기능 구현)
		- `ArrayList`, `HashSet` (실제 구현체)
- 사용 원칙
	- 인터페이스 타입으로 선언, 구현체로 초기화
	- 다양한 구현체로 교체 가능(다형성) → 코드 유연성 향상
``` java
List<String> list = new ArrayList<>();
Set<Integer> set = new HashSet<>();
Collection<Double> c = new ArrayList<>();
```
- HashSet 중복 검사
	- 데이터의 hashSet() → equals() 순으로 비교
	- `hashCode()`: 재정의 필요(같은 값은 같은 해시코드)
	- `equals()`: 재정의 필요(실제 동등성 비교)
- 제네릭(Java 5.0 도입)
	- 도입 전: `Object` 타입만 저장 가능 → 매번 형변환 필요, 런타임 에러 위험 향상
	- 도입 후: 타입을 명확히 지정 가능 → 안전성 향상, 형변화 불필요
	- `<E>`: Element → 여러 타입에 재사용 가능(`List<String>`, `List<Integer>` 등)
- 오토박싱/언박싱
	- 기본형 ↔ 래퍼 클래스 자동 변환 지원
``` java
List<Integer> list = new ArrayList<>();
list.add(1234);    // int → Integer 자동 변환 (오토박싱)
int x = list.get(0); // Integer → int 자동 변환 (언박싱)
```

