##### 상속과 다형성
- 학생 ==또는== 교사
	- "또는" 이라는 의미는 상위 타입 하나로 하위 타입을 담을 수 있다는 것
	- 즉, 부모 클래스의 참조변수는 자식 객체를 담을 수 있다 = 다형성
- 장점
	- 코드 재사용성 증가
	- 요구 사항 변경 시, 전체 구조를 바꾸지 않고 부분적 확장/변경으로 대응

##### 컴파일과 문자열 풀
- 컴파일 과정
	- 리터럴은 Literal Pool에 저장
	- 문자열 리터럴은 String Pool에서 관리 → 동일한 문자열 리터럴은 같은 주소를 참조
- 특징
	- 상수/리터럴은 프로그램 실행 시 메모리에 로딩됨.
	- 자바는 주소(참조값) 기반으로 객체를 관리 = reference 구조
	- 컴파일러는 타입을 엄격히 검사 → `int`와 `String` 같은 서로 다른 타입은 비교 불가

##### Object 클래스
- 모든 클래스의 최상위 조상 클래스는 Object
- 따라서 모든 클래스는 기본적으로 Object의 메서드를 상속받는다.
- ###### 주요 메서드 
	- `int hashCode()`
		- 객체의 해시값 반환(JVM이 객체의 메모리 주소 기반으로 생성)
		- 컬렉션에서 객체 구분 시 사용
	- `String toString()`
		- 객체의 정보를 문자열로 변환해 반환
		- 기본 구현은 클래스이름@해시값 형태이다.
		- 보통 개발자가 의미 있는 정보를 표현하도록 오버라이딩 한다.
	- `boolean equals(Object obj)`
		- 두 객체의 동등성 비교
		- 기본 구현은 주소값 비교
		- 값 비교가 필요하다면 오버라이딩 한다.

##### 콜백(Callback) 메서드
- 내가 직접 호출하지 않아도, 특정 이벤트/상황에서 시스템이나 프레임워크가 자동으로 호출하는 메서드

##### 데이터 중심 객체(VO)
- VO나 DTO 같은 데이터 객체는 `toString()` `hashCode()` `equals()` 오버라이딩을 권장

##### 일 잘한다 = 일을 잘 쪼갠다
- 일을 잘한다 → 일을 세분화해서 관리한다
- 즉, 큰 문제를 작은 단위로 쪼개어 분석과 설계를 잘하는 것이 핵심
- 작은 단위로 나누면 테스트, 유지보수, 개선이 쉬워진다.

##### 문제 해결 방식
- 버그 수정 시 한 번에 하나만 수정하는 것이 원칙
- 여러 부분을 동시에 수정하면, 어디서 문제가 발생했는지 추적이 어려워진다.
- → 원인 격리가 중요하다.

##### 생성자 구현 가이드
- 생성자는 매개변수가 많은 것부터 구현하는 것이 권장된다.
- 많은 매개변수를 받는 생성자가 "핵심 초기화 로직"을 담고 매개변수가 적은 생성자는 기본값을 넣거나 다른 생성자를 호출하는 방식으로 단순화.
- `this()`
	- 같은 클래스 내의 다른 생성자를 호출할 때 사용
	- 중복된 초기화 코드를 줄이고, 가독성과 유지보수성을 높임.