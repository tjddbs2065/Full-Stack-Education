##### 예외처리
- throw: 예외가 발생했다는 ==신호==를 상위 인터페이스에 ==전달==한다.
- throws: 해당 인터페이스에서 예외가 ==발생할 수도 있다==는 것을 상위 인터페이스에 ==알린다==.
- RuntimeException 같은 경우는 런타임에 발생하는 예외로, 컴파일러가 처리를 강제하지 않는다. 보통 프로그래밍 오류이므로, 개발자에게 선택권을 부여한다.
- CheckedException 같은 경우 컴파일 타임에 확인되는 예외로, 처리하지 않으면 컴파일 에러가 발생한다. 반드시 try/catch하거나 메서드 선언부에 throws를 명시해야 한다. 외부 요인에 의해 발생할 수 있어 반드시 대비해야 한다.
- 어디서 예외에 대한 제어를 해야할 지 잘 모르면 main에서 try/catch를 해 처리한다.
- 원하는 Exception이 없으면 Exception 클래스를 상속받아 원하는 예외처리를 하는 Exception을만들 수 있다.
- Exception을 상속받으면 부모 생성자에 message를 전달하여 원하는 예외 메세지를 출력할 수 있게 한다.
- throws 되는 Exception의 종류가 많다면 테스트 등의 코드에서는 이를 다 적을 필요 없이 Exception 하나로 처리해도 된다.
- 단, catch에서 Exception을 사용하면 모든 예외를 공통으로 처리할 수 있지만 그렇게 되면 특정 예외가 발생했을 때만 수행해야 하는 기능을 수행할 수 없게 된다. 따라서 이를 식별하고 분리하는 것이 필요하다.




##### Collection API
- 구현부를 확장할 수 없기에 interface이다.
- Set: 중복 체크
	- HashSet
- List: 순서 체크
	- ArrayList

- Collection은 인터페이스이고 List나 Set 인터페이스가 이를 상속받고 있다.
- ArrayList나 HashSet 같은 자료구조를 실제로 구현할 때는 List나 Set 인터페이스를 바로 상속받는게 아니라 중간에 공통 기능들을 구현해 놓은 AbstractSet, AbstractList가 존재한다.
- 실제로 사용할 때는 인터페이스로 타입을 선언하고, 그 변수에 실제 사용할 자료구조의 객체를 참조시킨다.(`List<int> list =  new ArrayList();`)
- 최종 부모는 Collection 인터페이스 이므로 `Collection c = new ArrayList();` 도 가능하게 된다.
- tip! 자바에서 1.5 버전부터 1234라는 값을 그대로 넣으면 int에서 Integer 래퍼 클래스로 자동으로 변환된다.
- 부모 클래스나 인터페이스로 타입을 선언하고 객체를 대입하게 되면 이는 개발자가 구현부의 다양성을 고려했다고 생각하면 된다.

 - HashSet에서 중복을 검사할 때 주소값이 아닌 데이터로 검사를 한다.
 - 때문에 hashCode()가 없으면 equals()
hashCode: 


Collection API 5.0 
- 제네릭을 도입하기 전 까지의 Collection에서는 Object 타입으로만 데이터를 저장할 수 있었다. 
- 하지만 이러면, 원하지 않는 타입도 컬렉션에 저장될 수 있고, 데이터를 꺼낼 때 마다 형변환을 해주어야 한다.
- 이는 런터임 에러가 발생하거나 가독성의 저하가 일어날 수 있다.
- 제네릭 도입 이후 컬렉션에 잘못된 타입을 넣는 것을 방지하고, 런타임 에러를 줄였다.
- 또한, 타입을 형변환 할 필요가 없고, ㅅ해당 클래스는 다양한 타입에 대해 재사용이 가능하게 되었다. `List<String>, List<Integer>` 등
- `<E>` : Element를 의미한다.