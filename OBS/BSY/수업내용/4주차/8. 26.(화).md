__DB__: 데이터들을 모아놓은 것
- 데이터를 보관만 하는 것이 아닌 사용하기 위한 것
- 이러한 데이터를 관리할 수 있도록 해주는 것이 DBMS
- 데이터를 통으로 넣는 것이 아닌 잘게 쪼개어 정리하면 관리하는 측면에서 좋다.
- 최소한의 중복: 디스크 용량이 부족했기에 중복되는 내용은 최대한 줄여야 한다.
	-> 관계형 데이터베이스(중복이 최소환 된 데이터를 저장하는 방식)
	-> 정규화(중복을 최소화 하는 과정)


역사
- 1980년대 도서관 같은 환경에서 데이터 공유에 문제 발생
- it 환경에서 데이터를 공유하는 시스템을 만들고 싶다
- 데이터를 통으로 읽어오면 메모리를 너무 많이 차지하니 부분적으로 데이터를 저장하고 불러올 때 그 부분만을 읽어와서 메모리의 용량 문제를 해결

##### 데이터베이스 설계
- 개념적 데이터 모델: 업무 범위로부터 특정 업무를 추출
- 논리적 데이터 모델: 관계 정의(정규화)
- 물리적 데이터 모델: 

- 개념 + 논리 모델링 : 업무 전문가(분석·설계)
	- 업무의 60 ~ 90%가 이 내용이다

- 초창기 데이터베이스에서는 고정 문자열을 많이 사용했다(char(6)).
- 현재의 데이터베이스는 가변 문자열을 많이 사용한다.
- 변수명도 저장하는 공간이 필요했기에 예전에는 짧게 사용했지만, 현재는 풀네임으로 사용하는게 트렌드.
- db 관리 요소 = 품질속성

- 정할 수 없는 데이터 - 모델링 불가(경험하면서 하나씩 처리하는 것이 효율)
- 데이터베이스 모델링 = 추상화 = 분석·설계

##### ERD(Entity Relation Diagram)
- 실선: 식별관계, 강한 연관관계, 필수관계
- 점선: 비식별관계, 느슨한 연관관계, 선택관계
- 정보공학 방법론을 기반으로 만듦.
- 최소한의 중복 = Primary Key를 말하는 것 = 나머지는 후보키
- 

SQL
- 쿼리: 데이터 조회
	- ==SELECT==
- DML: 데이터 ==값== 조작
	- INSERT
	- UPDATE
	- DELETE
- DDL: 데이터 ==구조== 조작 - 초창기에는 업무 전문가가 수행했음
	- CREATE
	- ALTER
	- DROP
- Transaction Control: 조작이 끝날 때 까지 접근하지 못하게 제한(업무 단위 ==그룹화==)
	- COMMIT
	- ROLLBACK
- DCL
	- GRANT
	- REVOKE

##### ORM(Object Relational Mapping)
- 객체와 관계형 DB의 매핑하여 객체지형적으로 사용할 수 있게 해준다. 

##### ORACLE
- sqlplus
- system
- alter user hr account unlock;
- alter user hr identified by hr;
- conn hr/hr
- select tname from tab;
- desc employees;
- 

- eclipse > project > new > other > eXERD > 리버스 엔지니어링

- Primary Key와 Foreign Key가 있을 때 이름이 같으면 좋지만 다른 경우가 있다.
- Oracle 기본 테이블 중 Employees이 employee_id 기본키는 Department 테이블에 manager_id로 외래키를 가진다. 이는 같은 값이다.
- Primary와 Foreign은 이름이 다를 수는 있지만, 타입과 값은 같아야 한다.
- 셀프로 관계 맺기(= employee_id - manager_id)
- 쿼리로 한번에 데이터를 가져오기 위해서는 테이블 간 관계가 맺어져 있어야 한다.
- 그렇지 않으면 여러번에 걸쳐 나눠서 데이터를 가져와야 한다.

##### 데이터 구조 도출 과정
1. Entity: 구조
2. Attribute: 값
3. Identifier: 식별자(속성 중 유일한 값)
4. Relation: 관계(식별자가 있어야 함)


##### 정규화
- 1차: 반복 속성 그룹을 Data를 보고 찾아낸다.
- 반복 될 상황을 예상해서 분할을 한다. 관계형 데이터베이스의 핵심
- 

##### 실습
```
사원의 사번, 이름을 확인
```
- 정보가 저장된 Entity 찾기
- 속성 정보 확인

```
사원의 사번, 급여, 보너스 금액, 총급여
```


## 📌 데이터베이스가 생기게 된 과정

### 1. 초창기: 파일 기반 데이터 관리의 한계

초기 컴퓨터 환경에서는 데이터를 저장하고 관리할 때 **운영체제의 파일 시스템**을 그대로 사용했습니다.

- 응용프로그램이 필요할 때마다 직접 파일을 열고 읽고 쓰는 방식.
    
- 그러나 이 방식에는 여러 가지 문제가 있었습니다.
    

**문제점 예시**

1. **중복성과 불일치**
    
    - 동일한 데이터를 여러 파일에 중복 저장 → 한쪽만 수정되면 불일치 발생.
        
2. **데이터 접근의 비효율성**
    
    - 데이터를 사용하려면 전체 파일을 메모리에 올려야 하는 경우가 많음.
        
    - 실제로 필요한 것은 일부분인데도 비효율적인 I/O 발생.
        
3. **동시성 제어 부재**
    
    - 여러 사용자가 동시에 파일을 수정하면 데이터가 꼬임.
        
4. **보안/무결성 부족**
    
    - 파일 수준에서는 접근 권한이나 무결성 제약 조건을 세밀하게 두기 어려움.
        

---

### 2. 문제 해결을 위한 새로운 접근

이러한 문제를 해결하기 위해 **데이터를 체계적으로 관리하는 전담 소프트웨어**, 즉 **데이터베이스 관리 시스템(DBMS)**이 등장했습니다.

**해결 방식**

1. **필요한 데이터만 읽어오기 (효율적 I/O)**
    
    - DBMS는 전체 파일을 한 번에 메모리에 올리는 대신, **페이지 단위·블록 단위로 일부만 로딩**하여 필요한 데이터만 효율적으로 가져올 수 있게 함.
        
    - 이는 저장장치의 용량 대비 메모리가 적었던 과거 컴퓨터 환경에서 매우 중요한 혁신이었음.
        
2. **데이터 중복 최소화와 통합 관리**
    
    - 스키마(데이터 구조)를 정의하고, 데이터를 한 곳에 모아 관리 → 불필요한 중복 제거, 일관성 유지.
        
3. **동시성 제어와 트랜잭션 도입**
    
    - 여러 사용자가 동시에 접근하더라도, DBMS가 잠금(lock)·트랜잭션을 통해 무결성을 보장.
        
4. **보안과 제약 조건 제공**
    
    - 사용자별 권한 제어, 무결성 제약(예: PRIMARY KEY, FOREIGN KEY)을 통해 데이터 신뢰성 강화.
        

---

### 3. DBMS의 발전

- **1960년대**: 초기 데이터 관리 시스템(예: IMS, CODASYL DBMS) → 계층형, 네트워크형 DB 등장.
    
- **1970년대**: E.F. Codd의 **관계형 데이터 모델(RDB)** 제안 → SQL 기반 DBMS로 발전.
    
- **1980~90년대**: Oracle, DB2, MS SQL Server, Sybase 등 상용 RDBMS 확산.
    
- **2000년대 이후**: 인터넷/빅데이터 환경 → 분산 DB, NoSQL, NewSQL 등으로 확장.