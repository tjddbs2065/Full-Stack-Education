##### 발언
1. 새로 배우는 것을 잘 모르겠을 땐 누군가가 미리 해놓은 것을 보고 학습해서 내 것으로 만들어라
2. 첫 술에 배부를 수 없다. -> 처음부터 바로 잘 할 수 없으니, 역으로 다른 사람들의 경험을 내가 경험해보는 것이 중요.
3. 어디든 들어가서 아무거나 하는것이 아니라 질적으로 참여하는 것이 중요
4. 정규화- 반복되는 기준을 찾아서 분할하는 것이 중요
5. 업무와 기술을 완벽하게 잘하는 것은 불가능에 가까움
6. 갑자기 우체국???
7. 업무를 배울 때 신입은 해보는 것이 좋고, 다양한 관점에서 바라보는 것이 중요한 경험이 된다.
8. 회사에서 원하는 인재상을 생각해보고 거기에 맞추는 것이 좋지 않을까

##### 오라클
1. employees를 통해 departments의 데이터를 찾으려면 어떻게 해야 하는가?
	1. join이나 sub query를 사용
	2. 이는 두 테이블이 연결되어 있기에 가능
2. 느슨한 연관관계가 멀리 떨어져 있는 테이블의 join이나 sub query가 매우 복잡해진다. 
   이는 단점이긴 하다.
3. 이를 해결하기 위해서는 강한 연관관계로 만들면 된다. 
4. 하지만 이는 키에 대한 정보를 사이에 있는 테이블들이 모두 가지고 있어야 하기에, 메모리를 많이 차지지게 된다.
5. 키가 중복이 되더라도 최소화 하는것이 권장된다.
6. 최근에는 느슨한 연관관계를 쿼리문이 너무 복잡해져서 비효율 적이라고 생각할 수도 있다.
7. 이건 업무에 따라 원하는 방식을 선택 하면 된다.
8. null을 허용한다는 것은 느슨한 관계이다.
9. 현업에서 신입한테 ERD를 보여주지 않는 경우가 다반사. DB 테이블의 정보를 확인해서 ERD를 역으로 추론할 수 있는 연습이 필요하다.
10. 요구사항이 들어오면 entity와 attribute를 찾아서 관계를 생각한다.
11. 오라클에서는 JOIN 하는 방법을 독자적인 문법으로 지원하고 있지만, 학습 목적 상 여러 DB를 사용할 계획이기에, SQL 표준에 맞춰 사용하는 것이 좋다.
12. 위와 같이 문법이 달라도 같은 기능을 수행하는 쿼리문이라 할 지라도, 세부적으로 보면 null을 처리하는지 아닌지 등에 따라 결과가 달라질 수 있으니, 잘 확인을 해야 한다.
13. 스키마는 대소문자를 구분하지 않지만, 데이터는 구분을 한다.
14. 테이블 생성을 예전에는 동시다발적으로 생성을 했었다.
15. 테이블을 만들 때 어떤 것을 우선해서 만들어야 하나? 
16. 테이블과 속성을 먼저 만들고 이후 관계를 형성(ALTER)한다.
17. DB의 데이터 타입에 BLOB이나 BFILE은 잘 사용하지 않는다. 대용량 파일을 DB 자체에 저장하지 않고, 컴퓨터 특정 공간에 보관하는 것이 효율적이기 때문.
18. 타입을 선택할 때 애플리케이션을 기준으로 선택한다.
19. getBigDecimal() 부분 놓침
20. eXERD에서 학생 정보를 담을 테이블 생성
21. 논리 모델링을 할 것이기에 한글로 네이밍을 한다.
22. 정규화를 하기 위해서는 샘플 데이터가 필요하다. 단순히 구조만 보고 판단을 할 수가 없다.
23. ddl의 특징은 트랜잭션과는 상관없이 바로바로 반영이 된다.
24. dml은 작업한 내용이 바로 적용되지 않는다.
25. 이 때 다른 사람이 동시에 db에 데이터를 삽입하려고 하면 바로 적용되지 않고 대기 상태가 된다.
26. 이를 해결하기 위해서는 현재 작업하고 있는 사람이 commit을 해서 작업 내용을 DB 반영을 하거나 rollback을 해서 작업 내용을 취소해야 한다.
27. 이를 트랜잭션 관리라고 한다.
28. DB에 데이터가 삽입될 때 순서대로 입력되지만 내부의 데이터 관리 규칙에 따라 빈 자리를 찾아 들어가서 순서의 보장이 되지 않는다.


##### 실습
``` SQL
사원의 사번, 이름, 근무 부서명을 확인

select employee_id, first_name || ' ' || last_name as name, departments.department_name 
from employees 
join departments on employees.department_id = departments.department_id;
```

``` SQL
2명의 사원이름(FN) Lex, Steven과 같은 부서에 속한 사원의 사번, 이름, 급여를 확인

select department_id, employee_id, first_name, salary 
from employees
where department_id in (
  select department_id 
  from employees 
  where first_name='Lex' or first_name = 'Steven'
);

select distinct e.employee_id, e.first_name, e.salary
from employees e
join employees x
	on x.department_id = e.department_id
	and x.first_name in ('Lex', 'Steven');

```

``` sql
고객 정보(아이디, 포인트, 가입날짜)

create table customers (
	customer_id varchar2(20) primary key,
	point number(10) not null,
	in_date date
);
```

```sql
특정 고객의 포인트를 10점 추가

update customers set point = point + 10 where customer_id = 'c002';
```
