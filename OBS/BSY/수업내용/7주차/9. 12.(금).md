##### 웹서버
- html의 공유

##### WAS
- 웹 서버에 application을 할 수 있도록 확장한 것(db 연결 등)
- Servlet: JDK를 사용할 수 있도록 해주는 API
- 과거에는 html을 db에 연결할 수 있는 방법이 없었다.
- 하지만 현재는 가능하고, 
- 왜 아직도 was를 사용하는가?
	- 전통
	- 보안
	- 성능
	- 유지보수
	- 옛날부터 계속해서 사용해 왔기에
	- 보안 문제: html 문서 내 코드가 그대로 노출되기에(java는 컴파일해서 사용한다)
	- jsp를 1차적으로 해석하는 주체는 java이다. 내부적으로 처리 후 결과로 텍스트만을 반환한다.
	- jsp 안에 모든 코드가 들어가기에 요청 할 때마다 컴파일을 해 요청 하나하나의 처리에 대한 속도가 늘어나 성능의 문제가 발생
- JavaBean: DAO, VO를 포함한 특정 업무의 패턴으로 묶어놓은 것
	- vm만 있으면 사용할 수 있는 모든 코드를 javabean이라고 한다.
	- 정의: JavaBean API Spec에 맞춰 작성된 사용자 정의 자바 클래스
		- 말이 너무 어렵다 ㅋㅋ
		- 그냥 특정 형태를 가진 자바 클래스
	- 규약(클래스 형태):
		- ==패키지가 있어야 한다.==
		- ==멤버는 private이고 getter/setter가 있다.==
		- ==기본 생성자==
		- 직렬화(선택) 
- Servlet
- tomcat
![[Pasted image 20250912115703.png]]
- target runtime: 사용할 웹서버 지정
- web module version: 
![[Pasted image 20250912114812.png]]
- context root: 작업 디렉터리(서버의 기본 시작 주소)
- content directory: 실제 파일(html 등)이 보관되는 디렉터리

![[Pasted image 20250912121200.png]]

![[Pasted image 20250912121217.png]]

- 서버 실행 시 포트가 중복되는 경우가 있다. 
- 필요한 경우 server.xml에서 서버 포트를 변경하여 사용할 수 있다.
![[Pasted image 20250912121541.png]]
- welcome-file을 index.html로 설정 = 기본 홈페이지 대상 설정
![[Pasted image 20250912123240.png]]


- jsp 코드는 서버에서 자바 컴파일을 해서 html에 해당하는 부분만을 뿌려준다.
- 내부 동작 코드는 보이지 않기에 보안 측면에서 좋다.
- jsp 코드가 수정되면 서버를 재시작 해야 한다.

![[Pasted image 20250912150907.png]]
- servlet은 servlet 계열의 클래스를 상속받아 사용해야 한다.
- package도 무조건 지정해 주어야 한다.

![[Pasted image 20250912151912.png]]
- servlet 3.0부터 애너테이션으로 @WebServlet을 사용한다. 이전에는 web.xml을 사용했다.

- 서버를 처음 시작했을 때도 servlet이 실행되지는 않는다.(= 최초 소스는 서버에 등록되지 않는다)
- 요청이 들어오면 서버에 servlet이 등록되며 생성자와 init이 호출된다.
- 요청을 처리할 때마다 service가 호출된다.
- 서버에 등록된 servlet이 해제되고 메모리에서 내려가기 직전에 destroy를 호출한다.
	- 소스가 바뀔 때, 오랜 기간 접근이 안될 때(메모리가 정리를 위해), 서버가 꺼지기 직전에 서버에 등록된 servlet의 destroy가 호출된다.
![[Pasted image 20250912161218.png]]


- request → servlet → response

- out : byte
- writer: 2byte
- stream: 연속해서

- jsp와 servlet은 서로 할 수 있는것은 서로 할 수 있다.
- jsp vs servlet : 기준에 따라 다르다. 보안 면에서는 servlet더 좋고, 제작 편의성 면에서는 jsp가 좋다.
- 꼭 둘 중 하나를 선택할 필요는 없고, 두 개의 장점을 모두 살려서 같이 사용해도 된다. 

- jsp는 서버에서 동작하는 것은 안 좋고, 브라우저에서 동작하기에는 좋다.
- request는 servlet이 받아서 db연동 등 내부적인 처리를 해주고, 원하는 처리가 끝나면 필요한 데이터만 jsp로 전달하여, 최종적으로 사용자의 브라우저에 jsp로 response로 뿌려주기만 한다.

- jsp가 내부적으로 servlet으로 바뀐다?

- request는 servlet이, response는 jsp가, db 연동은 javabean이 하는 형태의 패턴을 MVC Model2 이다.
- M(model): db와 연결되어 데이터 관련 처리를 한다.
- V(view): response에게는 model에 접근할 권한을 주면 안된다.(보안 문제, 사용자와 연결되는 부분)
- C(controller): request가 들어오면 model과 연동하여 처리한다.
- 이를 강제하는 환경(framework)를 구성한 것이 spring framework이다.

- 한국에서 문을 보면 당기세요, 미세요 라고 적혀있어도 이를 지키는 사람은 없다. 이는 이렇게 하세요 라고 권장하는 것이지만, 만약에 이를 원하지 않고 적혀 있는데로 하도록 강제하고 싶으면 이를 문을 열 수 있는 방향을 고정해 놓으면 된다.
- 마찬가지로, was는 여러 형태가 있지만 그 중 mvc model2라는 권장사항을 만들어 놓은 것이다.
- 

- 결국엔 httpservlet 쓰는 이유?
- servlet은 서버가 가지고 있어야 하는 기능에 대해서 정의해 놓은 것이다
- httpservlet은 웹서버가 가지고 있어야 하는 기능에 대해서 정의해 놓은 것이다.
	- 내부적으로 http가 가지고 있는 기능(request, response)에 대해서 정의되어 있다.

의문점
- servlet은 만들어 놓기만 하면 tomcat(was)이 알아서 가져가 사용하는 것인가?


# 1. 웹 1세대: 정적 웹 (Static Web, 1990년대 초)

- **방식**: 단순히 HTML 파일을 웹서버(Apache, NCSA httpd 등)가 브라우저에 그대로 전달
    
- **특징**:
    
    - 정적인 문서만 제공 (백과사전, 게시판 공지 같은 수준)
        
    - 사용자마다 다른 결과를 줄 수 없음
        
- **한계**: 맞춤형 서비스 불가 → “동적인 웹” 필요
    

---

# 2. CGI 시대 (Common Gateway Interface, 1990년대 중반)

- **방식**: 웹서버가 요청을 받으면, 외부 프로그램(Perl, C, Python 등)을 실행 → 결과를 HTML로 반환
    
- **특징**:
    
    - 사용자 입력에 따라 동적인 페이지 생성 가능
        
    - 로그인, 게시판 등 초기 동적 웹 구현 가능
        
- **한계**:
    
    - 요청마다 프로세스를 새로 생성 → 성능 저하
        
    - 유지보수 어려움 (언어/환경 제각각)
        

---

# 3. Servlet (1997, Java EE 초기)

- **등장 이유**: CGI의 성능 문제 해결 + 자바 생태계 활용
    
- **방식**:
    
    - 자바로 작성된 클래스가 **WAS(Servlet Container)** 안에서 상시 동작
        
    - 요청이 오면 스레드로 처리 → 훨씬 가볍고 빠름
        
- **특징**:
    
    - HTTP 요청/응답을 자바 객체(`HttpServletRequest`, `HttpServletResponse`)로 다룸
        
    - 재사용성, 안정성 높음
        
- **한계**:
    
    - HTML을 `out.println("<h1>...</h1>")` 식으로 자바 코드 안에 써야 함 → 개발 불편
        

---

# 4. JSP (Java Server Pages, 1999)

- **등장 이유**: Servlet의 HTML 작성 불편 해결
    
- **방식**: JSP 파일은 사실상 HTML 안에 자바 코드를 섞는 문법 → 실행 전 서블릿 클래스로 변환
    
- **특징**:
    
    - HTML 중심으로 작성 가능 → 프런트 개발자와 협업 용이
        
    - 자바 코드도 포함 가능 (`<% %>`)
        
- **한계**:
    
    - 로직과 화면이 뒤섞여 유지보수 어려움
        
    - MVC 패턴이 필요해짐
        

---

# 5. MVC 패턴 기반 웹 (2000년대 초~)

- **방식**:
    
    - **Servlet**: Controller → 요청 처리/흐름 제어
        
    - **JSP**: View → 결과 화면 출력
        
    - **JavaBean/DTO**: Model → 데이터 저장/전달
        
- **특징**:
    
    - 역할 분리 → 유지보수성, 협업성 증가
        
    - Spring MVC, Struts 같은 프레임워크 등장
        

---

# 6. 프레임워크 시대 (2000년대 중후반~)

- **Spring MVC (2003~)**: DI/IoC 기반, 대규모 웹 개발의 표준
    
- **Hibernate/JPA**: DB 연동 추상화
    
- **JSTL, EL(Expression Language)**: JSP 내 자바 코드 제거, 태그 기반 처리
    
- **특징**:
    
    - 개발자가 직접 JSP/Servlet 다루는 경우 줄고, **프레임워크가 내부적으로 Servlet을 사용**
        
    - 개발자는 주로 Controller/Service/Repository 같은 레이어 작성
        

---

# 7. 현대 웹 (2010년대~)

- **Ajax, SPA**: 프런트엔드와 백엔드가 명확히 분리 (React, Vue, Angular)
    
- **REST API / JSON**: 서버는 JSP 대신 JSON 응답을 주고, 프런트는 JS로 화면 구성
    
- **Spring Boot**: 설정 간소화, 빠른 서버 개발
    
- **클라우드 / 마이크로서비스**: WAS도 컨테이너(Docker, Kubernetes) 환경에서 실행