##### 웹서버
- 정적인 콘텐츠(static content)를 클라이언트(browser)에 전달하는 서버이다.
- HTML, CSS, JS, 이미지, 동영상 등이 해당된다.
- 대표적으로 Apache HTTP Server, Nginx, IIS 등이 있다.
> 클라이언트로부터 요청을 받으면, 요청 받은 파일을 그대로 응답으로 돌려주기만 한다.

##### WAS(Web Application Server)
- 동적 콘텐츠를 생성하는 서버이다.
- 클라이언트의 요청을 받아 로직(동작)을 수행하고 그 결과를 웹페이지로 만들어 반환한다.
- 대표적으로 Tomcat, WebLogic, WebSphere 등이 있다.
>단순히 요청받은 파일을 전달하는 것 뿐만 아니라, 로그인, DB 연동과 같은 프로그램 로직을 실행해 결과를 전달한다.


##### Servlet과 JSP
- Servlet
	- 자바로 작성된 서버 측 프로그램(클래스)
	- 클라이언트의 요청(HTTP Request)을 받아 처리하고, 결과를 HTML 형태로 응답(HTTP Response)한다.
	- Servlet Container가 Servlet의 실행을 관리(생명주기 등)한다.
- JSP
	- HTML 안에 자바 코드를 삽입할 수 있는 기술
	- JSP 최초 요청 시 WAS 내부에서 Servlet 코드로 변환하고 컴파일한다.
	- 이후 Servlet처럼 동작한다.
	- JSP는 개발 편의성을 위해 제공되는 문법적 설탕(sugar)일 뿐, 최종적으로는 Servlet이 된다.

##### 아직도 WAS를 사용하는 이유
- 과거 HTML 단독으로 DB 연동이나 로직 처리가 불가능했기에 자바 기반의 WAS가 필요했다.
1. 전통적 이유
	- 대규모 엔터프라이즈 환경은 오래전부터 Java/WAS 구조를 사용했다.
2. 보안
	- HTML/JS는 소스가 브라우저에 그대로 노출되지만, WAS에서 동작하는 자바 코드는 서버 내부에서 실행하고 결과(텍스트)만을 전송한다.
3. 성능/확장성
	- 컴파일된 자바 바이트코드 실행으로 속도와 안정성을 확보할 수 있다.
4. 유지보수
	- MVC 패턴, 스프링 프레임워크 등 체계적인 구조로 대규모 서비스 유지보수가 쉽다.
5. 호환성 & 신뢰성
	- 자바 기반 표준을 따라, 다양한 OS/플랫폼에서 실행이 가능하다.
##### WAS
- 웹 서버에 application을 할 수 있도록 확장한 것(db 연결 등)
- Servlet: JDK를 사용할 수 있도록 해주는 API
- 과거에는 html을 db에 연결할 수 있는 방법이 없었다.
- 하지만 현재는 가능하고, 
- 왜 아직도 was를 사용하는가?
	- 전통
	- 보안
	- 성능
	- 유지보수
	- 옛날부터 계속해서 사용해 왔기에
	- 보안 문제: html 문서 내 코드가 그대로 노출되기에(java는 컴파일해서 사용한다)
	- jsp를 1차적으로 해석하는 주체는 java이다. 내부적으로 처리 후 결과로 텍스트만을 반환한다.
	- jsp 안에 모든 코드가 들어가기에 요청 할 때마다 컴파일을 해 요청 하나하나의 처리에 대한 속도가 늘어나 성능의 문제가 발생
- JavaBean: DAO, VO를 포함한 특정 업무의 패턴으로 묶어놓은 것
	- vm만 있으면 사용할 수 있는 모든 코드를 javabean이라고 한다.
	- 정의: JavaBean API Spec에 맞춰 작성된 사용자 정의 자바 클래스
		- 말이 너무 어렵다 ㅋㅋ
		- 그냥 특정 형태를 가진 자바 클래스
	- 규약(클래스 형태):
		- ==패키지가 있어야 한다.==
		- ==멤버는 private이고 getter/setter가 있다.==
		- ==기본 생성자==
		- 직렬화(선택) 
- Servlet
- tomcat
![[Pasted image 20250912115703.png]]
- target runtime: 사용할 웹서버 지정
- web module version: 
![[Pasted image 20250912114812.png]]
- context root: 작업 디렉터리(서버의 기본 시작 주소)
- content directory: 실제 파일(html 등)이 보관되는 디렉터리

![[Pasted image 20250912121200.png]]

![[Pasted image 20250912121217.png]]

- 서버 실행 시 포트가 중복되는 경우가 있다. 
- 필요한 경우 server.xml에서 서버 포트를 변경하여 사용할 수 있다.
![[Pasted image 20250912121541.png]]
- welcome-file을 index.html로 설정 = 기본 홈페이지 대상 설정
![[Pasted image 20250912123240.png]]


- jsp 코드는 서버에서 자바 컴파일을 해서 html에 해당하는 부분만을 뿌려준다.
- 내부 동작 코드는 보이지 않기에 보안 측면에서 좋다.
- jsp 코드가 수정되면 서버를 재시작 해야 한다.

![[Pasted image 20250912150907.png]]
- servlet은 servlet 계열의 클래스를 상속받아 사용해야 한다.
- package도 무조건 지정해 주어야 한다.

![[Pasted image 20250912151912.png]]
- servlet 3.0부터 애너테이션으로 @WebServlet을 사용한다. 이전에는 web.xml을 사용했다.

- 서버를 처음 시작했을 때도 servlet이 실행되지는 않는다.(= 최초 소스는 서버에 등록되지 않는다)
- 요청이 들어오면 서버에 servlet이 등록되며 생성자와 init이 호출된다.
- 요청을 처리할 때마다 service가 호출된다.
- 서버에 등록된 servlet이 해제되고 메모리에서 내려가기 직전에 destroy를 호출한다.
	- 소스가 바뀔 때, 오랜 기간 접근이 안될 때(메모리가 정리를 위해), 서버가 꺼지기 직전에 서버에 등록된 servlet의 destroy가 호출된다.
![[Pasted image 20250912161218.png]]


- request → servlet → response

- out : byte
- writer: 2byte
- stream: 연속해서

- jsp와 servlet은 서로 할 수 있는것은 서로 할 수 있다.
- jsp vs servlet : 기준에 따라 다르다. 보안 면에서는 servlet더 좋고, 제작 편의성 면에서는 jsp가 좋다.
- 꼭 둘 중 하나를 선택할 필요는 없고, 두 개의 장점을 모두 살려서 같이 사용해도 된다. 

- jsp는 서버에서 동작하는 것은 안 좋고, 브라우저에서 동작하기에는 좋다.
- request는 servlet이 받아서 db연동 등 내부적인 처리를 해주고, 원하는 처리가 끝나면 필요한 데이터만 jsp로 전달하여, 최종적으로 사용자의 브라우저에 jsp로 response로 뿌려주기만 한다.

- jsp가 내부적으로 servlet으로 바뀐다?

- request는 servlet이, response는 jsp가, db 연동은 javabean이 하는 형태의 패턴을 MVC Model2 이다.
- M(model): db와 연결되어 데이터 관련 처리를 한다.
- V(view): response에게는 model에 접근할 권한을 주면 안된다.(보안 문제, 사용자와 연결되는 부분)
- C(controller): request가 들어오면 model과 연동하여 처리한다.
- 이를 강제하는 환경(framework)를 구성한 것이 spring framework이다.

- 한국에서 문을 보면 당기세요, 미세요 라고 적혀있어도 이를 지키는 사람은 없다. 이는 이렇게 하세요 라고 권장하는 것이지만, 만약에 이를 원하지 않고 적혀 있는데로 하도록 강제하고 싶으면 이를 문을 열 수 있는 방향을 고정해 놓으면 된다.
- 마찬가지로, was는 여러 형태가 있지만 그 중 mvc model2라는 권장사항을 만들어 놓은 것이다.
- 

- 결국엔 httpservlet 쓰는 이유?
- servlet은 서버가 가지고 있어야 하는 기능에 대해서 정의해 놓은 것이다
- httpservlet은 웹서버가 가지고 있어야 하는 기능에 대해서 정의해 놓은 것이다.
	- 내부적으로 http가 가지고 있는 기능(request, response)에 대해서 정의되어 있다.

의문점
- servlet은 만들어 놓기만 하면 tomcat(was)이 알아서 가져가 사용하는 것인가?

